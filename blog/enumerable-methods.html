<!DOCTYPE html>
<html>
<head>
  <title>Going Cycling</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/default.css">
    <link rel="stylesheet" type="text/css" href="../stylesheets/blog.css">
    <link href='https://fonts.googleapis.com/css?family=Slabo+27px|Raleway' rel='stylesheet' type='text/css'>
</head>
<body>
  <p id="home-link">
    <a href="http://stevenking86.github.io/blog/index.html">Blog Home</a>
  <header>
  <h1>Going Cycling</h1>
  <h2>Exploring the Enumerable#cycle method</h2>
  <h4>12/13/15</h4>
</header>

  <main>
    <p>
      After a quick look at the ruby-docs I didn't understand what the purpose of #cycle was at all. Does this thing just make infinite loops? How is that useful? The answers to those questions are "sort of" and "you'd be surprised!"
    </p>
    <p>
      The example shown in the ruby-docs doesn't really show everything that cycle can do. I'll show something similar here:
    </p>
    <pre><code>
list = [1,2,3]
list.cycle { |x| puts x}
=> 1
=> 2
=> 3
=> 1
=> 2
....and forever and ever and ever repeating
    </code></pre>
    <p>
      I was not enthused about my new ability to puts things to the screen forever. But I dug deeper and found some other methods that pair well with #cycle and then I thought of some ways it could be handy. The method we'll add in is #next.
    </p>
    <p>
      For the next example I'll show how #cycle and #next could be used for a game where multiple players take turns. I'll do a few things differently:
    </p>
    <pre><code>
names = ["Tommy", "Jane", "Billy"]
=> ["Tommy", "Jane", "Billy"]
turns = names.cycle
=>#Enumerator: ["Tommy", "Jane", "Billy"]:cycle>
turns.next
=> "Tommy"
turns.next
=> "Jane"
turns.next
=> "Billy"
turns.next
=> "Tommy"
    </code></pre>
    <p>
      So if turns.next is called it allows us to cycle through the names indefinitely, like players taking turns. It's much more useful than just printing them to the screen forever! Now if we use #cycle and #next with a hash as well, we can do some neat things. We'll pair it up with our names #cycle and have our 3 players play a pretty strange game.
    </p>
    <pre><code>
pieces = {"spinner"=>"spin twice", "dice"=>"roll once", "draw"=>"for 60 seconds", "act"=>"scene from a movie"}
=> {"spinner"=>"spin twice", "dice"=>"roll once", "draw"=>"for 60 seconds", "act"=>"scene from a movie"}
actions=pieces.cycle
=> #< Enumerator: {"spinner"=>"spin twice", "dice"=>"roll once", "draw"=>"for 60 seconds", "act"=>"scene from a movie"}:cycle>
5.times do
  player = turns.next
  do_what = actions.next
  puts "Now #{player} will #{do_what}"
end
Now Jane will ["spinner", "spin twice"]
Now Billy will ["dice", "roll once"]
Now Tommy will ["draw", "for 60 seconds"]
Now Jane will ["act", "scene from a movie"]
Now Billy will ["spinner", "spin twice"]
</code></pre>
    <p>
      So there we've got our players doing actions from our pieces hash. I ran the loop 5 times, but it could be run as many as needed since cycle is great at creating infinite loops. I hope this was an easy to understand crash course on how #cycle and #next can be used together to do some interesting things.
    </p>
  </main>
  <footer>
    <p>contact: <a href="mailto:stevenking86@gmail.com?Subject=Hello%20from%20your%20website" target="_top">stevenking86@gmail.com</a></p>
  </footer>

</body>

</html>